{#  TODO(yzshen): Consider merging the template code for user-defined and
    parameter data structs. That way we can eliminate validate(), fields(),
    encodes() and decodes(). #}

{#  Validates the specified struct field, which is supposed to be an object
    (struct/array/string/map/union).
    This macro is expanded by the validate() macro. #}
{%- macro _validate_object(struct, packed_field) %}
{%-   set name = packed_field.field.name %}
{%-   set kind = packed_field.field.kind %}
{%-   set wrapper_type = kind|cpp_wrapper_type %}
{%-   if not kind|is_nullable_kind %}
  if (!object->{{name}}.offset) {
    ReportValidationError(
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null {{name}} field in {{struct.name}} struct");
    return false;
  }
{%-   endif %}
  if (!mojo::internal::ValidateEncodedPointer(&object->{{name}}.offset)) {
    ReportValidationError(mojo::internal::VALIDATION_ERROR_ILLEGAL_POINTER);
    return false;
  }
{%-   if kind|is_array_kind or kind|is_string_kind %}
  if (!{{wrapper_type}}::Data_::Validate<
          {{kind|get_array_validate_params|indent(10)}}>(
              mojo::internal::DecodePointerRaw(&object->{{name}}.offset),
              bounds_checker)) {
{%-   elif kind|is_map_kind %}
  if (!{{wrapper_type}}::Data_::Validate<
          {{kind.value_kind|get_map_validate_params|indent(10)}}>(
              mojo::internal::DecodePointerRaw(&object->{{name}}.offset),
              bounds_checker)) {
{%-   elif kind|is_struct_kind %}
  if (!{{kind|get_name_for_kind}}::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->{{name}}.offset),
          bounds_checker)) {
{%-   else %}
  if (!{{wrapper_type}}::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->{{name}}.offset),
          bounds_checker)) {
{%-   endif %}
    return false;
  }
{%- endmacro %}

{# Validates the specified struct field, which is supposed to be a handle.
   This macro is expanded by the validate() macro. #}
{%- macro _validate_handle(struct, packed_field) %}
{%-   set name = packed_field.field.name %}
{%-   set kind = packed_field.field.kind %}
{%-   if not kind|is_nullable_kind %}
  if (object->{{name}}.value() == mojo::internal::kEncodedInvalidHandleValue) {
    ReportValidationError(
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
        "invalid {{name}} field in {{struct.name}} struct");
    return false;
  }
{%-   endif %}
  if (!bounds_checker->ClaimHandle(object->{{name}})) {
    ReportValidationError(mojo::internal::VALIDATION_ERROR_ILLEGAL_HANDLE);
    return false;
  }
{%- endmacro %}

{#  Validates the specified struct.
    This macro is expanded as the body of {{struct.name}}_Data::Validate(). #}
{%- macro validate(struct) %}
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, bounds_checker))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const {{struct.name}}_Data* object = static_cast<const {{struct.name}}_Data*>(data);

  static const uint32_t kVersionSizePairs[{{struct.versions|length}}][2] = {
{%-   for version in struct.versions -%}
    { {{version.version}}, {{version.num_bytes}} }{% if not loop.last %}, {% endif -%}
{%-   endfor -%}
  };

  if (object->header_.version <= {{struct.versions[-1].version}}) {
    for (size_t i = 0; i < {{struct.versions|length}}; ++i) {
      if (object->header_.version <= kVersionSizePairs[i][0]) {
        if (object->header_.num_bytes == kVersionSizePairs[i][1])
          break;

        ReportValidationError(
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes < {{struct.versions[-1].num_bytes}}) {
    ReportValidationError(
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

{#-   Before validating fields introduced at a certain version, we need to add
      a version check, which makes sure we skip further validation if |object|
      is from an earlier version. |last_checked_version| records the last
      version that we have added such version check. #}
{%-   set last_checked_version = 0 %}
{%-   for packed_field in struct.packed.packed_fields_in_ordinal_order %}
{%-     set kind = packed_field.field.kind %}
{%-     if kind|is_object_kind or kind|is_any_handle_kind %}
{%-       if packed_field.min_version > last_checked_version %}
{%-         set last_checked_version = packed_field.min_version %}
  if (object->header_.version < {{packed_field.min_version}})
    return true;
{%-       endif %}
{%-       if kind|is_object_kind %}
{{_validate_object(struct, packed_field)}}
{%-       elif kind|is_any_handle_kind %}
{{_validate_handle(struct, packed_field)}}
{%-       endif %}
{%-     endif %}
{%-   endfor %}

  return true;
{%- endmacro %}

{#  Declares a data member for the specified struct field.
    This macro is expanded by the fields() macro. #}
{%- macro _field_line(field) %}
{%-   set type = field.kind|cpp_field_type %}
{%-   set name = field.name -%}
{%-   if field.kind.spec == 'b' -%}
  uint8_t {{name}} : 1;
{%-   elif field.kind|is_enum_kind -%}
  int32_t {{name}};
{%-   else -%}
  {{type}} {{name}};
{%-   endif %}
{%- endmacro %}

{#  Declares data members for the specified struct.
    This macro is expanded in the {{struct.name}}_Data class declaration. #}
{%- macro fields(struct) %}
{%-   for packed_field in struct.packed.packed_fields %}
  {{_field_line(packed_field.field)}}
{%-     if not loop.last %}
{%-       set next_pf = struct.packed.packed_fields[loop.index0 + 1] %}
{%-       set pad = next_pf.offset - (packed_field.offset + packed_field.size) %}
{%-       if pad > 0 %}
  uint8_t pad{{loop.index0}}_[{{pad}}];
{%-       endif %}
{%-     endif %}
{%-   endfor -%}

{%-   set num_fields = struct.packed.packed_fields|length %}
{%-   if num_fields > 0 %}
{%-     set last_field = struct.packed.packed_fields[num_fields - 1] %}
{%-     set offset = last_field.offset + last_field.size %}
{%-     set pad = offset|get_pad(8) -%}
{%-     if pad > 0 %}
  uint8_t padfinal_[{{pad}}];
{%-     endif %}
{%-   endif %}
{%- endmacro %}

{#  Encodes the specified struct.
    Expands as the body of {{struct.name}}_Data::EncodePointersAndHandles(). #}
{%- macro encodes(struct) -%}
  MOJO_CHECK(header_.version == {{struct.versions[-1].version}});
{%-   for pf in struct.packed.packed_fields_in_ordinal_order %}
{%-     if pf.field.kind|is_object_kind %}
  mojo::internal::Encode(&{{pf.field.name}}, handles);
{%-     elif pf.field.kind|is_any_handle_kind %}
  mojo::internal::EncodeHandle(&{{pf.field.name}}, handles);
{%-     endif %}
{%-   endfor %}
{%- endmacro -%}

{#  Decodes the specified struct.
    This macro is expanded as the body of
    {{struct.name}}_Data:DecodePointersAndHandles(). #}
{%- macro decodes(struct) -%}
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
{#-   Before decoding fields introduced at a certain version, we need to add
      a version check, which makes sure we skip further decoding if |this|
      is from an earlier version. |last_checked_version| records the last
      version that we have added such version check. #}
{%-   set last_checked_version = 0 %}
{%-   for pf in struct.packed.packed_fields_in_ordinal_order %}
{%-     set name = pf.field.name %}
{%-     set kind = pf.field.kind %}
{%-     if kind|is_object_kind or kind|is_any_handle_kind %}
{%-       if pf.min_version > last_checked_version %}
{%-         set last_checked_version = pf.min_version %}
  if (header_.version < {{pf.min_version}})
    return;
{%-       endif %}
{%-       if kind|is_object_kind %}
  mojo::internal::Decode(&{{name}}, handles);
{%-       else %}
  mojo::internal::DecodeHandle(&{{name}}, handles);
{%-       endif %}
{%-     endif %}
{%-   endfor %}
{%- endmacro -%}

{#  Computes the serialized size for the specified struct.
    |struct| is the struct definition.
    |input_field_pattern| should be a pattern that contains one string
    placeholder, for example, "input->%s", "p_%s". The placeholder will be
    substituted with struct field names to refer to the input fields.
    This macro is expanded to compute seriailized size for both:
    - user-defined structs: the input is an instance of the corresponding struct
      wrapper class.
    - method parameters/response parameters: the input is a list of
      arguments.
    It declares |size| of type size_t to store the resulting size. #}
{%- macro get_serialized_size(struct, input_field_pattern) -%}
  size_t size = sizeof(internal::{{struct.name}}_Data);
{%-   for pf in struct.packed.packed_fields_in_ordinal_order if pf.field.kind|is_object_kind %}
  size += GetSerializedSize_({{input_field_pattern|format(pf.field.name)}});
{%-   endfor %}
{%- endmacro -%}

{#  Serializes the specified struct.
    |struct| is the struct definition.
    |struct_display_name| is the display name for the struct that can be showed
    in error/log messages, for example, "FooStruct", "FooMethod request".
    |input_field_pattern| should be a pattern that contains one string
    placeholder, for example, "input->%s", "p_%s". The placeholder will be
    substituted with struct field names to refer to the input fields.
    |output| is the name of the output struct instance.
    |buffer| is the name of the Buffer instance used.
    This macro is expanded to do serialization for both:
    - user-defined structs: the input is an instance of the corresponding struct
      wrapper class.
    - method parameters/response parameters: the input is a list of
      arguments. #}
{%- macro serialize(struct, struct_display_name, input_field_pattern, output, buffer) -%}
  internal::{{struct.name}}_Data* {{output}} =
      internal::{{struct.name}}_Data::New({{buffer}});
{%- for pf in struct.packed.packed_fields_in_ordinal_order %}
{%-   set input_field = input_field_pattern|format(pf.field.name) %}
{%-   set name = pf.field.name %}
{%-   set kind = pf.field.kind %}
{%-   if kind|is_object_kind %}
{%-     if kind|is_array_kind %}
  mojo::SerializeArray_<{{kind|get_array_validate_params|indent(24)}}>(
      mojo::internal::Forward({{input_field}}), {{buffer}}, &{{output}}->{{name}}.ptr);
{%-     elif kind|is_map_kind %}
  mojo::SerializeMap_<{{kind.value_kind|get_map_validate_params|indent(24)}}>(
      mojo::internal::Forward({{input_field}}), {{buffer}}, &{{output}}->{{name}}.ptr);
{%-     else %}
  Serialize_(mojo::internal::Forward({{input_field}}), {{buffer}}, &{{output}}->{{name}}.ptr);
{%-     endif %}
{%-     if not kind|is_nullable_kind %}
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !{{output}}->{{name}}.ptr,
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null {{name}} in {{struct_display_name}}");
{%-     endif %}
{%-   elif kind|is_any_handle_kind %}
{%-     if kind|is_interface_kind or kind|is_interface_request_kind %}
  {{output}}->{{name}} = {{input_field}}.PassMessagePipe().release();
{%-     else %}
  {{output}}->{{name}} = {{input_field}}.release();
{%-     endif %}
{%-     if not kind|is_nullable_kind %}
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !{{output}}->{{name}}.is_valid(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid {{name}} in {{struct_display_name}}");
{%-     endif %}
{%-   else %}
  {{output}}->{{name}} = {{input_field}};
{%-   endif %}
{%- endfor %}
{%- endmacro -%}

{#  Deserializes the specified struct.
    |struct| is the struct definition.
    |input| is the name of the input struct instance.
    |output_field_pattern| should be a pattern that contains one string
    placeholder, for example, "result->%s", "p_%s". The placeholder will be
    substituted with struct field names to refer to the output fields.
    This macro is expanded to do deserialization for both:
    - user-defined structs: the output is an instance of the corresponding
      struct wrapper class.
    - method parameters/response parameters: the output is a list of
      arguments. #}
{%- macro deserialize(struct, input, output_field_pattern) -%}
  do {
    // NOTE: The memory backing |{{input}}| may has be smaller than
    // |sizeof(*{{input}})| if the message comes from an older version.
{#-   Before deserialize fields introduced at a certain version, we need to add
      a version check, which makes sure we skip further deserialization if
      |input| is from an earlier version. |last_checked_version| records the
      last version that we have added such version check. #}
{%-   set last_checked_version = 0 %}
{%-   for pf in struct.packed.packed_fields_in_ordinal_order %}
{%-     set output_field = output_field_pattern|format(pf.field.name) %}
{%-     set name = pf.field.name %}
{%-     set kind = pf.field.kind %}
{%-     if pf.min_version > last_checked_version %}
{%-       set last_checked_version = pf.min_version %}
    if ({{input}}->header_.version < {{pf.min_version}})
      break;
{%-     endif %}
{%-     if kind|is_object_kind %}
    Deserialize_({{input}}->{{name}}.ptr, &{{output_field}});
{%-     elif kind|is_interface_kind or kind|is_interface_request_kind %}
    {{output_field}}.Bind(mojo::MakeScopedHandle(mojo::internal::FetchAndReset(&{{input}}->{{name}})));
{%-     elif kind|is_any_handle_kind %}
    {{output_field}}.reset(mojo::internal::FetchAndReset(&{{input}}->{{name}}));
{%-     elif kind|is_enum_kind %}
    {{output_field}} = static_cast<{{kind|cpp_wrapper_type}}>({{input}}->{{name}});
{%-     else %}
    {{output_field}} = {{input}}->{{name}};
{%-     endif %}
{%-   endfor %}
  } while (false);
{%- endmacro %}
